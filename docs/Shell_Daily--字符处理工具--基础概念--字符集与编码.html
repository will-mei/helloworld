<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>字符集与编码</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="Shell_Daily.html">Shell Daily</a></p>

<ol>
<li><a href="Shell_Daily--字符处理工具.html">字符处理工具</a></li>
<ol>
<li><a href="Shell_Daily--字符处理工具--基础概念.html">基础概念</a></li>
<ol>
<li><a href="Shell_Daily--字符处理工具--基础概念--计量单位.html">计量单位</a></li>
<li><a href="Shell_Daily--字符处理工具--基础概念--字符集与编码.html">字符集与编码</a></li>
<ol>
<li><a href="Shell_Daily--字符处理工具--基础概念--字符集与编码--ASCII字符对照表.html">ASCII字符对照表</a></li>
<li><a href="Shell_Daily--字符处理工具--基础概念--字符集与编码--汉字的Unicode编码.html">汉字的Unicode编码</a></li>
</ol>
<li><a href="Shell_Daily--字符处理工具--基础概念--基础补充.html">基础补充</a></li>
</ol>
<li><a href="Shell_Daily--字符处理工具--正则表达式.html">正则表达式</a></li>
<ol>
<li><a href="Shell_Daily--字符处理工具--正则表达式--命令中的正则表达式.html">命令中的正则表达式</a></li>
<li><a href="Shell_Daily--字符处理工具--正则表达式--正则表达式分类.html">正则表达式分类</a></li>
<li><a href="Shell_Daily--字符处理工具--正则表达式--元字符.html">元字符</a></li>
<ol>
<li><a href="Shell_Daily--字符处理工具--正则表达式--元字符--匹配字符.html">匹配字符</a></li>
<li><a href="Shell_Daily--字符处理工具--正则表达式--元字符--限定符.html">限定符</a></li>
<li><a href="Shell_Daily--字符处理工具--正则表达式--元字符--定位符.html">定位符</a></li>
</ol>
<li><a href="Shell_Daily--字符处理工具--正则表达式--普通字符.html">普通字符</a></li>
<ol>
<li><a href="Shell_Daily--字符处理工具--正则表达式--普通字符--非打印字符.html">非打印字符</a></li>
<li><a href="Shell_Daily--字符处理工具--正则表达式--普通字符--字符簇.html">字符簇</a></li>
</ol>
<li><a href="Shell_Daily--字符处理工具--正则表达式--运算优先级.html">运算优先级</a></li>
<li><a href="Shell_Daily--字符处理工具--正则表达式--常见正则表达式.html">常见正则表达式</a></li>
</ol>
<li><a href="Shell_Daily--字符处理工具--基础字符工具01_grep.html">基础字符工具01 grep</a></li>
<li><a href="Shell_Daily--字符处理工具--基础字符工具02_sed.html">基础字符工具02 sed</a></li>
<li><a href="Shell_Daily--字符处理工具--基础字符工具03_awk.html">基础字符工具03 awk</a></li>
<li><a href="Shell_Daily--字符处理工具--其他字符处理工具.html">其他字符处理工具</a></li>
</ol>
<li><a href="Shell_Daily--基础shell交互.html">基础shell交互</a></li>
</ol></div>
<div class="page"><h1><b><u>字符集与编码</u></b></h1>建议: Windows是通过对BOM(byte order mark)的识别来确认文件的编码的.如果使用Windows下的记事本来编辑文件,即使设定了保存为utf-8编码也<span style="color:#333333;">会在文件开始的地方插入三个不显示的字符</span>(直接看十六进制还是可以看见的),也就是BOM标记,用来辅助记事本等软件识别文件的编码,但是在Windows以外的系统下这样就会带来文本编码的识别错误.由于这一点很容易被忽略并且会导致编码识别出错,因此<span style="color:#333333;">是个大麻烦</span>,建议避免使用记事本修改代码文件,并在其他编辑器中设置不带BOM编码信息(without BOM)的格式工作, 如标准的utf-8编码(或者你工作平台需要的其他编码)作为默认编码.<br /><br /><br />通常情况下纯命令行环境下的文本字符处理过程中并不需要对字符编码进行处理,但是linux系统与我们常用的window桌面系统的字符编码并不相同,工作中难免需要跨平台进行一定的文本处理,比如在Windows系统下编辑的脚本和拷贝的文字很可能不能在linux环境下被正常识别出现乱码,这些是编写脚本需要注意的基本点,但这只是一些小问题,更重要的是当脚本需要处理中文编码的字符时,不了解字符编码恐怕就会很无助了,一般情况下我们都会避免在脚本中使用中文,但是如果需要处理的内容包含中文也还是必须得去解决问题的,因此了解一下字符编码也是必要的.<br /><br />理解字符编码比较容易,因为我们都知道计算机只能处理数字,如果要处理文本,就必须先把文本转换为数字才能处理。<br />最早的计算机在设计时采用8个比特(bit)作为一个字节(byte),也就是一个八位的二级制数,类似这样010000000, 并且以字节为单位进行字符编码,所以,一个字节能表示的最大的整数就是255(二进制11111111=十进制255), 0 - 255被用来表示大小写英文字母、数字和一些符号,这个编码表被称为ASCII(American Standard Code for Information Interchange)编码,它一个是单字节字符集,字符编码长度都在单字节以内(英文的字母数量也比较少),比如大写字母A的编码是65,小写字母z的编码是122.<br /><br />理解字符集也很简单,指定编码方案时收录了哪些字符,这种编码方案我们通常也就根据收录的内容叫他某种字符集,比如简体中文字符集,英文字符集等, ASCII编码就是一个英文字符集编码方案.<br /><br />ASCII编码几乎在所有的操作系统中被支持,它也仅仅包含了最基础的英文字符编码,下面我们可以借助python来直观的查看一下ASCII字符的编码<br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />执行命令(可以直接复制多行内容,并粘贴到终端中回车执行)<br />cat &gt;char_nu.py &lt;&lt;EOF<br />#!/usr/bin/env python<br /># coding=utf-8<br />import sys<br />char = sys.argv[1]<br />print(ord(char))<br />EOF<br /><br />添加执行权限<br />chmod +x char_nu.py<br /><br />运行并查看字母A的编码<br />./char_nu.py A<br /><br />输出结果:<br />65<br /><br />另, 如果系统中有安装python3,则还可以查看utf-8的中文编码,例如"中"字的编码<br />python3 ./char_nu.py 中<br /><br />输出结果:<br />20013<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />这里查看的实际也是Unicode的十进制编码.<br /><br />相比汉语字符,英文字母和符号的数量真的很少, ASCII编码连一个字节的数字都没有用完,它至今只规定了128个字符.<br /><br />显而易见,ASCII编码固然简单明了,但是除了英文字符还有很多种语言,他们也都需要编码才能被计算机处理,故此针对不同的语言就诞生了不同的字符编码方案了,他们收录的字符范围也有所差异,也就产生了众多范围不同的字符集,比如,简体中文的GB2312编码字符集(GB 是国标,微软在 GB2312 的基础上扩展了 GBK),在台湾香港地区普遍使用的繁体中文BIG5编码字符集,以及包含简繁中文的GBK(GBK的简体部分兼容GB2312,但是繁体部分与big5不相同)编码字符集等.<br />虽然编码众多,但是, 一般的,ASCII码字符被多数语言编码兼容.<br /><br />因为不同语言包含的基础字符数量是不同的,汉字拥有常用现代汉字数7000多个,目前最全的汉字字库显示我国的有出处汉字90000多个(如果加上中国被发现并可以记录不同写法的汉字并一起编码总数量会有更多,ヽ(￣д￣;)ノ,但是很多古文字符通常跟语言演变有关,考古系的研究生们认识的也就两万左右,普通人的识字量一般是三五千左右,很多汉字在现代语言不再使用,有些也没有被常用的字符集统计收录,即使是Unicode中针对中日韩文的cjk编码也是增加了好几个相关的补充区),如此多的字符一个字节肯定是没法统一标识并编码的,因此需要更长的数字记录标记它们, 所以汉字编码通常至少是双字节(16位)为单位的.<br />像中国、日本和韩国的象形文字符这样, 采用两个字符长度编码的字符集就成了双字节字符集（DBCS：double-byte character set）, 它们通常也会兼容ASCII码字符,因此会有字符集内的部分字符一个字节部分字符两个字节, 这样兼容ASCII码会导致附加的程序设计问题,处理起来相对繁琐,因为字符串中的字符数不能由字符串的字节数决定,所以字符解码变得更复杂了.<br /><br />字符集太多,问题非常明显, 先不说各自编码的长度问题,编码太多了,大家交换信息很不方便啊,即使是相同的文字,如果编辑时文本所采用的字符集不同也仍然需要经过转换才能被各自的计算机软件识别并使用.<br />为了能有一个字符集包含尽量多的字符,也有一些将区域内多个相关性较强的语言文字统一进行编码的字符集规范出现,比如包含中文日文朝鲜语的GB18030,这样区域的软件之间信息沟通虽然方便一些,但是由于字符集过多且不统一, 国际网络信息交流还是不方便.<br /><br />进一步的, 如果有一个字符集包含所有的的世界通用字符岂不是更好,顺应发展潮流, 于是有了国际标准化组织(ISO)与多语言软件制造商组成的协会所共同制定的Unicode字符集标准,Unicode可以用来表示所有语言的字符,全面而唯一,也不兼容任何编码,而且是定长双字节(绝大多数常用语言字符都在Unicode的基本语言平面内,通常是双字节的,但也有四字节的辅助平面字符)编码,解码也比较方便.<br />需要注意,Unicode规定了字符的标识编码方法,但是没有规定配套的具体存储编码方法, 并不是一个全面集成的程序字符处理解决方案. Unicode主要是为了解决统一各语言字符集的问题而催生出来的, 所以它的主要成就是给出了一个全面的字符集编码方案,解决了多语言统一的文字收录, 简而言之,就是Unicode编码为每个字符规定一个用来表示该字符的数字. <br />Unicode编码由六位十六进制数构成一个总的代码空间,按照平面plane(前两位从00到10表示,编号为#0到#16,共17个,当前Unicode标准只用了其中少数几个平面)为单位划分大的区域,同时(利用后四位0000-FFFF的两个字节表示)各平面内包含65535个码点, 用于定位语言字符, Unicode表总共包含了1114112个码点,即从000000(十六进制) - 10FFFF(十六进制)。<br />当前几乎地球上所有字符都可以在Unicode表中找到对应的唯一码点。参考查询Unicode字符的网页链接 <a href="https://unicode-table.com/cn/">https://unicode-table.com/cn/</a><br />Unicode统一了字符收录编码标准,但它其实是一个符号集,规定了所有字符对应的码点,可以方便字符的统一处理,因此很多编程语言与软件都使用Unicode对字符编码进行处理,但是Unicode编码存储起来却不够经济,Unicode编码后的大小是一样的.例如一个英文字母 "a" 和　一个汉字 "好",编码后数字长度是一样的,如果直接存储,它们都是两个字节,此时英文的存储空间浪费了3倍!(如果考虑基础平面以外的一起按照4个字节统一存储浪费就更严重了)当你面对频繁的字符处理工作中只需要用到英文字母的情况时,明显采用八位二进制编码的ASCII字符集更好,短编码对磁盘和内存的空间的利用都会更加高效. 如果存储空间浪费,那么传输的时候带宽也会被一起浪费,传输起来也会更慢,因此我们需要有了统一的字符集我们还需要一套相对灵活经济的存储编码解决这个问题.<br /><br />对于再进一步的空间利用率问题上,我们希望将字符的编码尽可能变短,节省空间,同时最好对于每个字符编码的占用空间判断不要太复杂,这样解码也能方便高效.<br />为了较好的解决 Unicode 的存储和传输的经济性问题, 出现了一些将Unicode格式转换后再使用的编码字符集,因为Unicode对字符做了较为完备的收录,所以他们主要关注传输中的编码, 这种命题下UTF(Unicode Transformation Format, Unicode通用转换格式)系列 UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了(还有其他UTF编码,如,UTF-32 的编码方式,字符统一使用 4 个字节,不如另外两种编码方式使用广泛).<br /><br />至此,我们需要明确两个概念:<br /> Unicode,一套完备的全球通用字符集.<br /> UTF格式,一系列针对Unicode传输存储的通用编码转换格式.<br /><br />UTF系列格式的字符集都属于中间格式的字符集,准确来说,我们应该说他们是UTF编码或UTF格式,因为它们自己并不解决字符收录问题,都是与Unicode搭配,是由Unicode转换而来的,是一种Unicode的"再编码". UTF-8和UTF-16以及UTF-32等等是为了满足不同的场景需求,而在格式上由Unicode使用不同字符长度控制策略转换得到,因此空间利用效率和复杂性侧重程度不同.<br />UFT-8:一种变长的编码方案,使用 1~6 个字节来存储,兼容ASCII编码;<br />UFT-32:一种固定长度的编码方案,不管字符编号大小,始终使用 4 个字节来存储;<br />UTF-16:介于 UTF-8 和 UTF-32 之间,使用 2 个或者 4 个字节来存储,长度既固定又可变.<br />注意,只有 UTF-8 兼容 ASCII, UTF-32 和 UTF-16 都不兼容 ASCII, 因为它们没有单字节编码.<br /><br />我们来看一下utf-8的字符编码过程<br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />由于所处的范围不同,随着数字的增长字符的编码长度也会逐渐增长,utf-8采用了根据所在范围使用不同样式编码的可变长编码方法.请看下表:<br /><table class="table"><col/><col/><col/><col/><tr><th>Unicode 十六进制码点范围</th><th>UTF-8 二进制编码样式</th><th>编码总字节数</th><th>码点信息长度</th></tr><tr><td>0000 0000   0000 007F</td><td>0xxxxxxx</td><td>单字节</td><td>7位</td></tr><tr><td>0000 0080   0000 07FF</td><td>110xxxxx 10xxxxxx</td><td>双字节</td><td>11位</td></tr><tr><td>0000 0800   0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td><td>三字节</td><td>16位</td></tr><tr><td>0001 0000   0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td><td>四字节</td><td>21位</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></table><br />注, 这里只列出到两个字节的字符,只有少数地区使用的字符才需要 4~6个字节存储.<br /><br />上面可以看到,<br />如果一个字节的开头是10,那么它就代表是某一段编码的继续,<br />如果开头是0,那么代表单字节字符,<br />如果开头是连续的N个1,那么代表它是一个N字节字符的开始.<br /><br />"汉"字的Unicode编号为 U+6c49,在基础语言平面BMP中, 而6c49是具体的码点十六进制数字,该数字位于三字节编码区间(0x0800-0xFFFF),该字符需要使用三个字节完成编码,于是<br /><br />将6c49转换成二级制,长度为15位<br />110 1100 0100 1001<br /><br />需要使用的编码样式<br />1110xxxx 10xxxxxx 10xxxxxx <br /><br />我们调整以下间距,看一下需要填充的各段数字<br />xxxx xxxxxx xxxxxx<br />0110 110001 001001<br /><br />从右向左逐段填充,不足的用0补充,得到<br />1110 0110 1011 0001 1000 1001<br /><br />将结果转换成十六进制表示<br />E6B189<br /><br />完成<br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />进制转换方法:<br /># Windows可以使用计算器的程序员模式完成转换<br /># linux下可以安装并使用bc完成转换<br /># echo "obase=2;ibase=16; 6C49"| bc<br /><br />我们现在使用的linux系统下大部分情况下字符普遍是采用utf-8方式作为默认编码的,在绝大多数的linux发行版都是采用该编码,如果有兴趣进一步了解其他的几种编码方式,可以自行查阅网络资料,这里就不再作介绍了.</div></div>
</body></html>